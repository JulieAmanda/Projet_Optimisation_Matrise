{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 Menlo-Italic;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Menlo-Bold;
}
{\colortbl;\red255\green255\blue255;\red83\green101\blue121;\red255\green255\blue255;\red0\green0\blue0;
\red100\green56\blue32;\red196\green26\blue22;\red155\green35\blue147;\red92\green38\blue153;\red28\green0\blue207;
\red36\green82\blue86;\red50\green109\blue116;\red57\green0\blue160;}
{\*\expandedcolortbl;;\csgenericrgb\c32401\c39745\c47507;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c0\c0\c0;
\csgenericrgb\c39147\c22031\c12446;\csgenericrgb\c77000\c10200\c8600;\csgenericrgb\c60759\c13753\c57628;\csgenericrgb\c35922\c14825\c60191;\csgenericrgb\c11000\c0\c81000;
\csgenericrgb\c13924\c32052\c33684;\csgenericrgb\c19418\c42935\c45455;\csgenericrgb\c22454\c0\c62803;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab593
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f0\i\fs24 \cf2 \cb3 //
\f1\i0 \cf4 \

\f0\i \cf2 //  main.cpp
\f1\i0 \cf4 \

\f0\i \cf2 //  Projet_v2
\f1\i0 \cf4 \

\f0\i \cf2 //
\f1\i0 \cf4 \

\f0\i \cf2 //  Created by JULIE AMANDA TCHOUANDEM KEMOE on 2020-09-16.
\f1\i0 \cf4 \

\f0\i \cf2 //  Copyright \'a9 2020 JULIE AMANDA TCHOUANDEM KEMOE. All rights reserved.
\f1\i0 \cf4 \

\f0\i \cf2 //
\f1\i0 \cf4 \
\
\cf5 #include \cf6 <iostream>\cf4 \
\cf5 #include \cf6 "samples.hpp"\cf4 \
\cf5 #include \cf6 "projectParameters.h"\cf4 \
\cf5 #include \cf6 "subPb.hpp"\cf4 \
\cf5 #include \cf6 "mainfile_complements.hpp"\cf4 \
\cf5 #include \cf6 "globalModel.hpp"\cf4 \
\cf5 #include \cf6 "subgradientMethod.hpp"\cf4 \
\
\

\f2\b \cf7 using
\f1\b0 \cf4  
\f2\b \cf7 namespace
\f1\b0 \cf4  \cf8 std\cf4 ;\
\
\
\
\

\f2\b \cf7 int
\f1\b0 \cf4  main(
\f2\b \cf7 int
\f1\b0 \cf4  argc, 
\f2\b \cf7 const
\f1\b0 \cf4  
\f2\b \cf7 char
\f1\b0 \cf4  * argv[]) \{\
    \
    
\f0\i \cf2 //***   commen\'e7ons par construire les structures de donn\'e9es \'e0 utiliser \'e0 partir des donn\'e9es prises dans les fichiers echantillons  ***//
\f1\i0 \cf4 \
\
    
\f2\b \cf7 int
\f1\b0 \cf4  m =  \cf9 0\cf4 ;\
    
\f2\b \cf7 int
\f1\b0 \cf4   n = \cf9 0\cf4  ;\
    \cf10 get_M_N\cf4 (m, n); 
\f0\i \cf2 //on va recuperer les valeurs de m et n contenues dans le fichier
\f1\i0 \cf4 \
    \
    
\f0\i \cf2 //on construit les structures de donn\'e9es dont on aura pour stocker les donn\'e9es
\f1\i0 \cf4 \
    
\f2\b \cf7 int
\f1\b0 \cf4  * tOffre = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 [m];\
    
\f2\b \cf7 int
\f1\b0 \cf4  * tDemand = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 [n]; 
\f0\i \cf2 //on choisit de reserver 100
\f1\i0 \cf4 \
    \
    
\f2\b \cf7 int
\f1\b0 \cf4 ** tCoutFix = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 *[m];\
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i = \cf9 0\cf4 ; i < m; ++i)\
        tCoutFix[i] = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 [n];\
    \
    
\f2\b \cf7 int
\f1\b0 \cf4 ** tCoutVar = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 *[m];\
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i = \cf9 0\cf4 ; i < m; ++i)\
        tCoutVar[i] = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 [n];\
    \
    
\f2\b \cf7 int
\f1\b0 \cf4 ** tCapacity = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 *[m];
\f0\i \cf2 // va contenir la capacit\'e9 des diff\'e9rentes routes
\f1\i0 \cf4 \
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i = \cf9 0\cf4 ; i < m; ++i)\
        tCapacity[i] = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 [n];\
    \
    
\f0\i \cf2 // on va lire toutes donn\'e9es dans le fichier selon le groupe auquel appartient le file
\f1\i0 \cf4 \
    
\f0\i \cf2 // il existe 2 dossiers. et selon le dossier, la disposition des fichiers est differente
\f1\i0 \cf4 \
    
\f2\b \cf7 if
\f1\b0 \cf4  (\cf11 datasetGroup\cf4 ==\cf9 2\cf4 )\
        \cf10 readInput_Dataset2\cf4 (m, n, tOffre, tDemand,tCoutVar, tCoutFix);\
    
\f2\b \cf7 else
\f1\b0 \cf4  
\f2\b \cf7 if
\f1\b0 \cf4  (\cf11 datasetGroup\cf4 ==\cf9 3\cf4 )\
        \cf10 readInput_Dataset3\cf4 (m, n, tOffre, tDemand,tCoutVar, tCoutFix);\
    
\f2\b \cf7 else
\f1\b0 \cf4 \
        \cf8 cout\cf4  << \cf6 "ce dataset Group est inexistant"\cf4 ;\
    \
    
\f0\i \cf2 //on va construire le tableau des capacit\'e9s
\f1\i0 \cf4 \
    \cf10 BuiltCapacity\cf4 (m, n, tOffre, tDemand, tCapacity);\
    \
    \
\
    
\f0\i \cf2 //***  On va maintenant construire le probl\'e8me par d\'e9compositiion lagrangienne en construisant des sous probl\'e8mes par noeud et recuperant les valeurs de chaque variables par noeud ***//
\f1\i0 \cf4 \
    \
    
\f2\b \cf7 int
\f1\b0 \cf4  ** tVal_NdSrc = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 *[m];
\f0\i \cf2 //ici on va stocker les valeurs des flots des noeuds sources
\f1\i0 \cf4 \
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i = \cf9 0\cf4 ; i < m; ++i)\
        tVal_NdSrc[i] = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 [n];\
    \
    \
    
\f2\b \cf7 int
\f1\b0 \cf4  ** tVal_NdDest= 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 * [n];  
\f0\i \cf2 //ici on va stocker les valeurs des flots des noeuds destinations
\f1\i0 \cf4 \
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  j = \cf9 0\cf4 ; j < n; ++j)\
        tVal_NdDest[j] = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 [m];\
    \
    
\f2\b \cf7 int
\f1\b0 \cf4  ** tabSubgradient= 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 * [n];  
\f0\i \cf2 //table qui va contenir les sous-gradient apr\'e8s resolution des sspb
\f1\i0 \cf4 \
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  j = \cf9 0\cf4 ; j < n; ++j)\
        tabSubgradient[j] = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 [m];\
    \
    
\f0\i \cf2 //construisons les tables qui contiendra les valeurs des objectifs pour chaque noeud pr
\f1\i0 \cf4 \
    \
    
\f2\b \cf7 float
\f1\b0 \cf4  * ValObjSrc = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 float
\f1\b0 \cf4 [m];\
    
\f2\b \cf7 float
\f1\b0 \cf4  * ValObjDest= 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 float
\f1\b0 \cf4 [n];\
    
\f2\b \cf7 float
\f1\b0 \cf4  valObj = \cf9 0\cf4 ; 
\f0\i \cf2 //ici on va recuperer le resultat \'e0 partir des sous-pb pour le garder ds le tableau
\f1\i0 \cf4 \
    \
    \cf8 cout\cf4 << m<< \cf12 endl\cf4 ;\
    \cf8 cout\cf4  <<n << \cf12 endl\cf4 ;\
   \
    \
    
\f0\i \cf2 //  --> c'est \'e0 partir d'ici qu'on doit commencer la m\'e9thode it\'e9rative car on doit faire les calcul des sspbs et les autres... ainsi de suite jusqu'a ce que x_ij\'88d= x_ij\'88s
\f1\i0 \cf4 \
    \
    
\f0\i \cf2 // *** variables qui seront utilis\'e9es pour l'algorithme de sous-gradient
\f1\i0 \cf4 \
    \
    
\f2\b \cf7 bool
\f1\b0 \cf4  algoStop= 
\f2\b \cf7 false
\f1\b0 \cf4  ;\
    
\f2\b \cf7 int
\f1\b0 \cf4  maxIteration = \cf11 omga_4\cf4 ;\
    \
    \
    \

\f0\i \cf2 /*  r\'e9solution des sous probl\'e8mes pour les noeuds sources */
\f1\i0 \cf4 \
    \
    
\f0\i \cf2 //on va fixer les S \'e0 0 pour un d\'e9but
\f1\i0 \cf4 \
    
\f2\b \cf7 float
\f1\b0 \cf4  tAlpha_i [n];\
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i=\cf9 0\cf4 ; i<n; i++)\
        tAlpha_i[i]=\cf9 0\cf4 ;\
    
\f2\b \cf7 float
\f1\b0 \cf4  nu=\cf9 0.5\cf4 ;\
    \
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i=\cf9 0\cf4 ; i<m; i++)\{\
        \
        
\f0\i \cf2 //on va afficher les donn\'e9es utiles pour ce sous-Pb
\f1\i0 \cf4 \
        \cf8 cout\cf4  << \cf12 endl\cf4 ;\
        \cf8 cout\cf4  << \cf6 "***  Noeud source : num\'e9ro "\cf4  << i <<\cf6 "   ***     "\cf4 <<\cf12 endl\cf4 ;\
        \cf10 affich_subPbData\cf4 (tOffre[i], tCapacity[i], tCoutVar[i], tCoutFix[i], m, n); 
\f0\i \cf2 //voir la fonction dans mainfile_compliments.hpp
\f1\i0 \cf4 \
\
        \
        
\f0\i \cf2 //on r\'e9soud le sous-probl\'e8me pour le noeud i
\f1\i0 \cf4 \
        \cf10 ssPbSrc_i\cf4 ( i, tAlpha_i, nu,  tVal_NdSrc[i], tOffre[i],\
              tCapacity[i], tCoutVar[i], tCoutFix[i], n, valObj);\
        \
        ValObjSrc[i]=valObj;\
        \
        \cf10 makeSpace\cf4 (); 
\f0\i \cf2 // mettre de l'espace dans l'affichage (voir mainfile_complements.hpp
\f1\i0 \cf4 \
    \}\
\
\

\f0\i \cf2 /* ***** r\'e9solution des sous_pb pour les noeuds destination  --------- */
\f1\i0 \cf4 \
    \
    \cf10 makeSpace\cf4 ();\
    \cf8 cout\cf4 << \cf6 "partie Destination "\cf4 << \cf12 endl\cf4 ;\
    \
    
\f0\i \cf2 //construisons les tables \'e0 passer en param\'e8tres au sous_prob du cot\'e9 destination
\f1\i0 \cf4 \
    
\f2\b \cf7 int
\f1\b0 \cf4  t1 [m]; 
\f0\i \cf2 //on va prendre ici la colonne j du tableau des capacit\'e9s u_ij
\f1\i0 \cf4 \
    
\f2\b \cf7 int
\f1\b0 \cf4  t2 [m];\
    
\f2\b \cf7 int
\f1\b0 \cf4  t3 [m];\
    \
    \
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  j=\cf9 0\cf4 ; j<n; j++)\{\
        \
        
\f0\i \cf2 // etant donn\'e9 que pour le souspb du cot\'e9 destination \'e0 un noeud j on a besoin de tableau contenant les capacit\'e9, couts fixes et variables \'e0 partir du noeud j, on va construire les tableaux contenant ces donn\'e9es \'e0 partir des matrices tcapacity, tcoutFix et tCoutVar
\f1\i0 \cf4 \
        
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i=\cf9 0\cf4 ;i<m;i++) \{\
            t1[i]= tCapacity[i][j];\
            t2[i]=tCoutVar[i][j];\
            t3[i]=tCoutFix[i][j]; \}\
        \
        
\f0\i \cf2 // affichons les donn\'e9es pour v\'e9rification
\f1\i0 \cf4 \
        \cf8 cout\cf4  << \cf12 endl\cf4 ;\
        \cf8 cout\cf4  << \cf6 "***  Noeud Destination : num\'e9ro "\cf4  << j <<\cf6 "  ***     "\cf4 <<\cf12 endl\cf4 ;\
\
         \cf10 affich_subPbData\cf4 (tDemand[j], t1, t2, t3, m, n); 
\f0\i \cf2 //voir la fonction dans mainfile_compliments.hpp
\f1\i0 \cf4 \
        \
        
\f0\i \cf2 //table contenant les multiplicateurs de lagrange
\f1\i0 \cf4 \
        
\f2\b \cf7 float
\f1\b0 \cf4  tAlpha_j [m];\
        
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i=\cf9 0\cf4 ; i<m; i++)\
            tAlpha_j[i]=\cf9 0\cf4 ;\
\
        \
        \
        \
        \
        
\f0\i \cf2 //\'e0 pr\'e9sent on fait appel au ss_pb cot\'e9 Dest
\f1\i0 \cf4 \
         \cf10 ssPbDest_j\cf4 ( j, tAlpha_j,  nu, tVal_NdDest[j], tDemand[j], t1 ,t2, t3,  m, valObj); 
\f0\i \cf2 // voir file subPb.cpp
\f1\i0 \cf4 \
     \
        ValObjDest[j]= valObj;\
        \
        \cf10 makeSpace\cf4 (); 
\f0\i \cf2 // on fait de l'espace dans l'affichage ( voir mainfile_compliments.hpp)
\f1\i0 \cf4 \
    \}\
    \

\f0\i \cf2 /* ---------- fin subPBDest ---------- */
\f1\i0 \cf4 \
    \
    \
    \
    \

\f0\i \cf2 //  **** calcul d une borne min et sup de la solution \'e0 partir des resultats des sous probl\'e8mes.
\f1\i0 \cf4 \
    \
    
\f2\b \cf7 float
\f1\b0 \cf4  bMin = \cf10 borneMin\cf4 (m, n, ValObjSrc, ValObjDest); 
\f0\i \cf2 // calcul borne Min -- voir subgradientMethod.cpp
\f1\i0 \cf4 \
    \
    \cf10 makeSpace\cf4 (); 
\f0\i \cf2 // espace entre les paragraphes \'e0 l'affichage
\f1\i0 \cf4 \
    \cf8 cout\cf4  << \cf6 " ***   borne min : "\cf4  <<  bMin<<\cf6 "   ***  "\cf4 <<\cf12 endl\cf4 ;
\f0\i \cf2 // val de borne minimale
\f1\i0 \cf4 \
    \cf10 makeSpace\cf4 (); 
\f0\i \cf2 // espace entre les paragraphes \'e0 l'affichage
\f1\i0 \cf4 \
    \
    \cf8 cout\cf4  << \cf6 "resolvons  le probl\'e8me global \'e0 la racine pour obtenir une borne sup\'e9rieure ..."\cf4  << \cf12 endl\cf4 ;\
    \
    
\f0\i \cf2 //  calcul de la borne sup -- voir globalModel.cpp
\f1\i0 \cf4 \
    
\f2\b \cf7 float
\f1\b0 \cf4  bornSup = \cf10 ModelBase_Bsup\cf4 ( m , n, tOffre, tDemand, tCoutVar, tCoutFix, tCapacity);\
\
    \cf10 makeSpace\cf4 (); 
\f0\i \cf2 // espace entre les paragraphes  \'e0 l'affichage
\f1\i0 \cf4 \
    \cf8 cout\cf4  << \cf6 " ***    borne sup : "\cf4  <<  bornSup <<\cf6 "   ***  "\cf4 <<\cf12 endl\cf4 ;\
    \
 \
    \
 
\f0\i \cf2 /* --- affichage des solutions des ssPb et comparaison  --- */
\f1\i0 \cf4 \
    \
    \cf8 cout\cf4  << \cf6 "tab x_ij\'88s"\cf4  << \cf12 endl\cf4 ;\
    \cf10 affichTabSolutions\cf4 (m, n, tVal_NdSrc);\
\
    \
    
\f0\i \cf2 //    commencons par transposer la matrice des x_ij\'88d afin de pouvoir comparer si les solutions sont \'e9gales pourdes i,j \'e9gaux des 2 cot\'e9s sources et destinations. la diff\'e9rence nous permettra d'obtenir le sous grandient plus tard
\f1\i0 \cf4 \
    \
    
\f0\i \cf2 // on va cr\'e9er un nouveau tableau transpos\'e9 pour y retranscrire les donn\'e9es.
\f1\i0 \cf4 \
    
\f2\b \cf7 int
\f1\b0 \cf4  ** tVal_NdDest2 = 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4 * [m];\
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i=\cf9 0\cf4 ; i<m; i++)\
        tVal_NdDest2[i]= 
\f2\b \cf7 new
\f1\b0 \cf4  
\f2\b \cf7 int
\f1\b0 \cf4  [n];\
    
\f0\i \cf2 //construisons la transpos\'e9e
\f1\i0 \cf4 \
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i=\cf9 0\cf4 ; i<m; i++)\{\
        
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  j=\cf9 0\cf4 ; j<n; j++)\
            tVal_NdDest2[i][j]= tVal_NdDest[i][j];\}\
    \
    \
    \cf8 cout\cf4  << \cf12 endl\cf4 ;\
    \cf8 cout\cf4  << \cf6 "tab x_ij\'88d"\cf4  << \cf12 endl\cf4 ;\
    \cf10 affichTabSolutions\cf4 (m,n, tVal_NdDest2 );  
\f0\i \cf2 //affichons la transpos\'e9e -- voir fonction dans subgradient.cpp
\f1\i0 \cf4 \
    \
    
\f0\i \cf2 //calcul du sousgradient -- voir subgradient.cpp
\f1\i0 \cf4 \
    \cf10 calcul_subGradient\cf4 ( m, n, tVal_NdSrc, tVal_NdDest2, tabSubgradient);\
\
    \cf8 cout\cf4  << \cf12 endl\cf4 ;\
    \cf8 cout\cf4  << \cf6 "tab alpha_i_j"\cf4  << \cf12 endl\cf4 ;\
    \cf10 affichTabSolutions\cf4 (m,n,tabSubgradient ); 
\f0\i \cf2 //   affichons la table des sous-gradients
\f1\i0 \cf4 \
    \
    \
    \
    
\f0\i \cf2 //  --> entre ces deux fl\'e8ches , reflechir comment impl\'e9menter la m\'e9thode ss-gradient
\f1\i0 \cf4 \
    \
    
\f0\i \cf2 //  ***  on libere les pointeurs qui ont ete utiliser pour stocker les donn\'e9es
\f1\i0 \cf4 \
    \
\
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i=\cf9 0\cf4 ; i<m; i++)\
    \{\
        
\f2\b \cf7 delete
\f1\b0 \cf4  [] tCoutFix[i];\
        
\f2\b \cf7 delete
\f1\b0 \cf4  [] tCoutVar[i];\
        
\f2\b \cf7 delete
\f1\b0 \cf4  [] tCapacity[i];\
    \}\
    \
    
\f2\b \cf7 delete
\f1\b0 \cf4  [] tCoutFix;\
    
\f2\b \cf7 delete
\f1\b0 \cf4  [] tCoutVar;\
    
\f2\b \cf7 delete
\f1\b0 \cf4  [] tCapacity;\
    \
    
\f2\b \cf7 delete
\f1\b0 \cf4  [] tOffre;\
    
\f2\b \cf7 delete
\f1\b0 \cf4  [] tDemand;\
    \
    \
    \
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i = \cf9 0\cf4 ; i < m; ++i)\
        
\f2\b \cf7 delete
\f1\b0 \cf4  [] tVal_NdSrc[i];\
    
\f2\b \cf7 delete
\f1\b0 \cf4  [] tVal_NdSrc;\
    \
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  j = \cf9 0\cf4 ; j < n; ++j)\
        
\f2\b \cf7 delete
\f1\b0 \cf4  [] tVal_NdDest[j];\
    
\f2\b \cf7 delete
\f1\b0 \cf4  [] tVal_NdDest;\
        \
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i = \cf9 0\cf4 ; i < m; ++i)\
        
\f2\b \cf7 delete
\f1\b0 \cf4  [] tVal_NdDest2[i];\
    
\f2\b \cf7 delete
\f1\b0 \cf4  [] tVal_NdDest2;\
    \
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  i = \cf9 0\cf4 ; i < m; ++i)\
        
\f2\b \cf7 delete
\f1\b0 \cf4  [] tabSubgradient[i];\
    
\f2\b \cf7 delete
\f1\b0 \cf4  [] tabSubgradient;\
    \
    
\f2\b \cf7 delete
\f1\b0 \cf4  [] ValObjSrc;\
    
\f2\b \cf7 delete
\f1\b0 \cf4  [] ValObjDest;\
    \
    \
    
\f2\b \cf7 return
\f1\b0 \cf4  \cf9 0\cf4 ;\
\}\
}